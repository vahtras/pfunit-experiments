module test_so_fock
use pfunit_mod
implicit none

@testcase
    type, extends(TestCase) :: type_rsphso
        double precision, allocatable, dimension(:, :) :: h2
        double precision, allocatable, dimension(:, :) :: fc
        double precision, allocatable, dimension(:, :) :: q
        double precision, allocatable, dimension(:, :) :: udv
        double precision, allocatable, dimension(:, :, :, :) :: pv
        double precision, allocatable, dimension(:) :: wrk
    contains
        procedure :: setUp, tearDown
    end type

contains

subroutine setUp(this)
    use inforb_mod, only: muld2h, nsym, norbt, nisht, nasht, &
        iorb, norb, nish, iash ,nash, nocc
    use infind_mod, only: ismo, isx, isw, iobtyp
    use wrkrsp_mod, only: ksymop
    class(type_rsphso), intent(inout) :: this
    
    integer i

    muld2h = reshape(&
             (/1,2,3,4,5,6,7,8, &
               2,1,4,3,6,5,8,7, &
               3,4,1,2,7,8,5,6, &
               4,3,2,1,8,7,6,5, &
               5,6,7,8,1,2,3,4, &
               6,5,8,7,2,1,4,3, &
               7,8,5,6,3,4,1,2, &
               8,7,6,5,4,3,2,1/), (/8, 8/))
! inforb.h
    nsym = 1
    norbt = 6
    nisht = 1
    nasht = 2
    iorb(1) = 0
    norb(1) = 6
    nish(1) = 1
    iash(1) = 0
    nash(1) = 2
    nocc(1) = 3

! infind.h
    ismo(1:norbt) = 1
    do i=1,norbt
        isx(i) = i
        isw(i) = i
    end do
    iobtyp(1) = 2
    iobtyp(2:3) = 3
    iobtyp(4:6) = 4

! wrkrsp.h
    ksymop = 1

    allocate(this%h2(norbt, norbt)); this%h2 = 0
    allocate(this%fc(norbt, norbt)); this%fc = 0
    allocate(this%q(norbt, nasht));  this%q = 0
    allocate(this%udv(nasht, nasht)); this%udv = 0
    allocate(this%pv(nasht, nasht, nasht, nasht)); this%pv = 0
    allocate(this%wrk(10))

end subroutine setUp

subroutine tearDown(this)
    class(type_rsphso), intent(inout) :: this
    deallocate(this%h2)
    deallocate(this%fc)
    deallocate(this%udv)
    deallocate(this%pv)
    deallocate(this%wrk)
end subroutine tearDown


@test
subroutine test_ceqd_gives_naught(this)
    use rsphso_mod, only: append_to_fi
    class(type_rsphso), intent(inout) :: this

    this%h2 = 1d0
    this%fc = 0d0

    call append_to_fi(1, 1, this%h2, this%fc, this%wrk, size(this%wrk))
    @assertEqual(maxval(abs(this%fc)), 0d0)
end subroutine

@test
subroutine test_fi_zero_input(this)
    use rsphso_mod, only: append_to_fi
    class(type_rsphso), intent(inout) :: this


    this%h2 = 0d0
    this%fc = 0d0


    call append_to_fi(2, 1, this%h2, this%fc, this%wrk, size(this%wrk))
    @assertEqual(maxval(abs(this%fc)), 0d0)
end subroutine

@test
subroutine test_fi_coulomb(this)
    use rsphso_mod, only: append_to_fi_c
    class(type_rsphso), intent(inout) :: this
    double precision:: ref_fc(6, 6) = 0d0


    this%h2 = 1d0
    this%fc = 0d0
    ref_fc(2, 1) = 2d0
    ref_fc(1, 2) = -2d0

    call append_to_fi_c(2, 1, this%h2, this%fc, this%wrk, size(this%wrk))
    @assertEqual(0d0, maxval(abs(this%fc - ref_fc)))
end subroutine

@test
subroutine test_fi_exchange(this)
    use rsphso_mod, only: append_to_fi_x
    class(type_rsphso), intent(inout) :: this
    double precision:: ref_fc(6, 6) = 0d0


    this%h2 = 1d0
    this%fc = 0d0
    ref_fc(2, :) = -3
    ref_fc(:, 2) = 3
    ref_fc(2, 2) = 0

    call append_to_fi_x(2, 1, this%h2, this%fc, this%wrk, size(this%wrk))
    @assertEqual(0d0, maxval(abs(this%fc - ref_fc)))
end subroutine

@test
subroutine test_q1_update(this)
    use inforb_mod, only: norbt, nasht
    use rsphso_mod, only: update_q1
    class(type_rsphso), intent(inout) :: this

    double precision ref_q(norbt, nasht)
    ref_q = 0

    call update_q1(this%q, this%h2, 3, 2, this%pv)
    @assertEqual(ref_q, this%q)

end subroutine

@test
subroutine test_q1_update_1232a(this)
    use inforb_mod, only: norbt, nasht
    use rsphso_mod, only: update_q1
    class(type_rsphso), intent(inout) :: this

    double precision ref_q(norbt, nasht); ref_q = 0
    ! q(1,2) = (12|32) d(1,1,2,1)

    this%h2(1, 2) = 7
    this%pv(1, 1, 2, 1) = 9
    ref_q(1, 1) = 63

    call update_q1(this%q, this%h2, 3, 2, this%pv)
    @assertEqual(ref_q, this%q)

end subroutine

@test
subroutine test_q1_update_1232b(this)
    use inforb_mod, only: norbt, nasht
    use rsphso_mod, only: update_q1
    class(type_rsphso), intent(inout) :: this

    double precision ref_q(norbt, nasht); ref_q = 0
    ! q(1,2) = (12|32) d(1,1,2,1)

    this%h2(1, 2) = 7
    this%pv(1, 1, 1, 2) = 9
    ref_q(1, 1) = -63

    call update_q1(this%q, this%h2, 3, 2, this%pv)
    @assertEqual(ref_q, this%q)

end subroutine

end module test_so_fock

